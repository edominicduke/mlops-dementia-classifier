"""
This script assesses the data quality of the dementia dataset we will
be using in our ML pipeline to train our simple classification model.
"""
import pandas as pd
import numpy as np

# Download the dataset as a pandas DataFrame.
df = pd.read_csv("data/raw/dementia_dataset.csv")
print(df.head(10))
print("")

# Report the number of duplicated rows.
print("Number of duplicated rows:", df.duplicated().sum())
print("")

# Find possible inconsistent values for the variables.

# I) Value Checks

# Check that Group ∈ {Nondemented, Demented, Converted} and print the number of values that do not follow this criteria.
group_column = df["Group"]
num_group_vals_not_in_subset = (group_column[~group_column.isin(["Demented", "Nondemented", "Converted"])]).size # Generated by Gemini 2.5 Flash at 11:56 AM On 11/20/25
print("Number of values that do not satisfy Group ∈ {Nondemented, Demented, Converted}:", num_group_vals_not_in_subset)
print("")

# Check that M/F ∈ {M, F} and print the number of values that do not follow this criteria.
m_f_column = df["M/F"]
num_m_f_vals_not_in_subset = (m_f_column[~m_f_column.isin(["M", "F"])]).size
print("Number of values that do not satisfy M/F ∈ {M, F}:", num_m_f_vals_not_in_subset)
print("")

# Check that Hand ∈ {R} (only right-handed people for this dataset) and print the number of values that do not follow this criteria.
hand_column = df["Hand"]
num_hand_vals_not_in_subset = (hand_column[~hand_column.isin(["R"])]).size
print("Number of values that do not satisfy Hand ∈ {R}:", num_hand_vals_not_in_subset)
print("")

# Check that Age ∈ [60, 96] and print the number of values that do not follow this criteria.
age_column = df["Age"]
num_age_vals_not_in_range = age_column[age_column < 60].size + age_column[age_column > 96].size
print("Number of values that do not satisfy Age ∈ [60, 96]:", num_age_vals_not_in_range)
print("")

# Check that MMSE ∈ [0, 30] and print the number of values that do not follow this criteria.
mmse_column = df["MMSE"]
num_mmse_vals_not_in_range = mmse_column[mmse_column < 0].size + mmse_column[mmse_column > 30].size
print("Number of values that do not satisfy MMSE ∈ [0, 30]:", num_mmse_vals_not_in_range)
print("")

# Check that CDR ∈ {0, 0.5, 1, 2, 3} and print the number of values that do not follow this criteria.
cdr_column = df["CDR"]
num_cdr_vals_not_in_subset = (cdr_column[~cdr_column.isin([0, 0.5, 1, 2, 3])]).size
print("Number of values that do not satisfy CDR ∈ {0, 0.5, 1, 2, 3}:", num_cdr_vals_not_in_subset)
print("")

# Check that SES ∈ [1, 5] and print the number of values that do not follow this criteria.
ses_column = df["SES"]
num_ses_vals_not_in_range = ses_column[ses_column < 1].size + ses_column[ses_column > 5].size
print("Number of values that do not satisfy SES ∈ [1, 5]:", num_ses_vals_not_in_range)
print("")

# Check that EDUC ∈ [5, 25] and print the number of values that do not follow this criteria.
educ_column = df["EDUC"]
num_educ_vals_not_in_range = educ_column[educ_column < 5].size + educ_column[educ_column > 25].size
print("Number of values that do not satisfy EDUC ∈ [5, 25]:", num_educ_vals_not_in_range)
print("")

# Check that nWBV ∈ [0, 1] and print the number of values that do not follow this criteria.
nwbv_column = df["nWBV"]
num_nwbv_vals_not_in_range = nwbv_column[nwbv_column < 0].size + nwbv_column[nwbv_column > 1].size
print("Number of values that do not satisfy nWBV ∈ [0, 1]:", num_nwbv_vals_not_in_range)
print("")

# Check that eTIV > 0 and print the number of values that do not follow this criteria.
etiv_column = df["eTIV"]
num_etiv_vals_not_in_range = etiv_column[etiv_column <= 0].size
print("Number of values that do not satisfy eTIV > 0:", num_etiv_vals_not_in_range)
print("")

# Check that ASF > 0 and print the number of values that do not follow this criteria.
asf_column = df["ASF"]
num_asf_vals_not_in_range = asf_column[asf_column <= 0].size
print("Number of values that do not satisfy ASF > 0:", num_asf_vals_not_in_range)
print("")

# II) Logical Checks

# Logical Check 1: If Group = "Nondemented" or Group = "Converted" → CDR should be 0. Otherwise, >= 0.5.
num_invalid_logical_check_1 = 0
num_invalid_logical_check_1 += df[((df["Group"] == "Nondemented") | (df["Group"] == "Converted")) & ~(df["CDR"] == 0)].size
num_invalid_logical_check_1 += df[(df["Group"] == "Demented") & (df["Group"] == 0)].size
print("Number of values that fail Logical Check 1 (Group and CDR):", num_invalid_logical_check_1)
print("")

# Logical Check 2: Visit 1 should not being having an MR Delay with more than 30 days.
num_invalid_logical_check_2 = 0
num_invalid_logical_check_2 += df[(df["Visit"] == 1) & (df["MR Delay"] > 30)].size
print("Number of values that fail Logical Check 2 (Visit 1 and MR Delay):", num_invalid_logical_check_2)
print("")

# Create an array with the column labels corresponding to numerical columns (found from printed output in assess_data_structure.py)
numerical_vars = ["Visit", "MR Delay", "Age", "EDUC", "SES", "MMSE", "CDR", "eTIV", "nWBV", "ASF"]

# Report the number of outliers that may need attention for each numerical variable.
for var in numerical_vars:
    print(var + ": ")
    var_column = df[var]
    q1 = var_column.describe()["25%"]
    q3 = var_column.describe()["75%"]
    num_vals_less_than_q1 = (var_column[var_column < q1]).size
    num_vals_greater_than_q3 = (var_column[var_column > q3]).size
    num_outliers = num_vals_less_than_q1 + num_vals_greater_than_q3
    print("Number of Outliers:", num_outliers)
    print("")